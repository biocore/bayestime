N = length(unique(df$id))
J = 2
nknots = params[[1]][[J]]
Q = nknots + 4
K = params[[2]][[J]]
sigma_eps = sqrt(params[[5]][[J]]) # SIGMA_OMEGA_true is error variance
Q1 = params[[1]][[1]] + 4
K1 = params[[2]][[1]]
Theta = params[[6]][(1+Q1):(Q+Q1), (1+K1):(K+K1)] # THETA_true
theta_mu = params[[7]][(1+Q1):(Q+Q1)] # MU_true
ALPHA = t(ALPHA[[1]][(1+K1):(K+K1), ]) # ALPHA
Group = ifelse(ALPHA[, 1] > -0.1, 'G1', 'G2') # 49 in G1 and 51 in G2
# basis
phi_t = phi_t[[J]]
phi_t_stacked=NULL
for(i in 1:N){
phi_t_stacked = rbind(phi_t_stacked, t(phi_t[[i]]))
}
## simulated data
time = Y = MU = F = Omega = Alpha = list()
ids=rep(1:N,each=1)
for (i in 1:N){
time[[i]] = TIME_SPARSE[[1]][[i]][[J]]
Y[[i]] = Y_SPARSE[[1]][[i]][[J]]
MU[[i]] = MU_SPARSE[[1]][[i]][[J]]
F[[i]] = F_SPARSE[[1]][[i]][[J]]
Omega[[i]] = OMEGA_SPARSE[[1]][[i]][[J]]
}
#change not to standardize_kathy_0927
prepared_data <- prepare_data(data = df, unique_subject_id = 'id', time_name = 'time',
response_name = 'response', scale_time = T) # standardized
load('../../../results_pkg/bayesTime_sim_N100_M80_nostandardized.RData')
optimal_model_idx <- optimal(model_list = sfpca_stan_results)
optimal_model <- sfpca_stan_results[[optimal_model_idx]]
#--------------------------------------------
# check model results
#--------------------------------------------
model_output <- output_results(sfpca_data = prepared_data, model = optimal_model)
results_basis = basis_setup_sparse(sfpca_data=prepared_data, nknots=nknots, orth=TRUE)
ALPHA_array = model_output$rotation$alpha_new
MU_array = model_output$rotation$theta_mu_new
THETA_array = model_output$rotation$Theta_new
phi_t_cont = result_basis$orth_spline_basis_cont
phi_t_cont = results_basis$orth_spline_basis_cont
time_cont = results_basis$time_cont
N = prepared_data$num_subjects
MU_true = params[[7]][(1+Q1):(Q+Q1)]
FPC_true = params[[8]][, (1+K1):(K+K1)]
time = Y = list()
ids=rep(1:N,each=1)
for (i in 1:N){
time[[i]] = TIME_SPARSE[[1]][[i]][[J]]
Y[[i]] = Y_SPARSE[[1]][[i]][[J]]
}
time_sparse = time # coming from wide format: sampling time point for each subject
Y_sparse = Y # coming from wide format: response for each subject
time_unique = unique(df$time)
time_unique = time_unique[order(time_unique)]
nloop=dim(ALPHA_array)[3]
first=1
last=nloop
MU_mean=MU_array[, 1]
for(iter in 2:nloop){
MU_mean = MU_mean + MU_array[, iter]
}
MU_mean=cbind(MU_mean/(last-first+1))
library(Matrix)
phi_transform = Matrix::bdiag(cbind(phi_t_cont))
Mu_true_functions=t(phi_transform)%*%MU_true
Mu_functions=model_output$Mu_functions
Mu1_true=Mu_true_functions[1:length(time_cont)] # referring to 1st block
Mu1=Mu_functions[1:length(time_cont)]
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10), xlim=c(0,1),lwd=2,col=4,
xlab='time', ylab='Response', font.lab=2, cex.lab=1.2)
for(i in 1:N){
lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)
}
lines(time_cont,Mu1,type="l",col=2,lwd=2)
legend('topright', c('True', 'Estimated'), col=c(4, 2), lty=c(1,1), bty='n')
THETA_mean = THETA_array[,,first]
for(iter in 2:nloop){
THETA_mean = THETA_mean + THETA_array[,,iter]
}
THETA_mean=cbind(THETA_mean/(last-first+1))
FPC1_mean=model_output$FPC_mean
plot(time_unique,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)),
xlab='time', ylab='PC curve', font.lab=2, cex.lab=1.2)
lines(time_unique,FPC_true[,2],type="l",lwd=1)
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)
legend('topright', c('True', 'Estimated'), col=c(1, 2), lty=c(1,1), bty='n')
matrix(c(5,0,0,0,8,7,0,7,9), byrow = T, ncol=3)
a <- matrix(c(5,0,0,0,8,7,0,7,9), byrow = T, ncol=3)
inv(a)
inverse(a)
library(matlib)
library(Matrix)
inv(a)
solve(a)
1/8
knitr::opts_chunk$set(echo = TRUE)
library(haven)
data <- read_sas('completedata.sas7bdat')
summary(data)
attach(data)
plot(data$Fatalism, data$Depression, pch=18, ylab = 'Depression',
xlab = 'Fatalism', main = 'Scatterplot')
fit <- lm(Depression ~ Fatalism)
summary(fit)
confint(fit)
anova(fit)
x_bar <- mean(Fatalism)
y_bar <- mean(Depression)
ssxy <- sum((Depression - y_bar) * (Fatalism - x_bar))
ssx <- sum((Fatalism - x_bar)^2)
b1 <- ssxy / ssx
b0 <- y_bar - b1 * x_bar
n <- length(Fatalism)
y_hat <- b0 + b1*Fatalism
sse <- sum((Depression - y_hat)^2)
ssr <- sum((y_hat - y_bar)^2)
mse <- sse / (n - 2)
msr <- ssr / 1
fstat <- msr / mse
1-pf(q=fstat, df1=1, df2 = n-2)
anova(fit)
q1 <- quantile(Fatalism, 0.25)
q3 <- quantile(Fatalism, 0.75)
iqr <- q3 - q1
q2 <- median(Fatalism)
Fatalism_std <- (Fatalism - q2) / iqr
hist(Fatalism)
hist(Fatalism_std)
fit2 <- lm(Depression ~ Fatalism_std)
summary(fit2)
confint(fit2)
plot(Fatalism_std, Depression, pch=18)
abline(fit2, col='red')
anova(fit2)$F[1]
anova(fit)$F[1]
anova(fit2)$F[1]==anova(fit)$F[1]
option(digits=8)
options(digit=8)
anova(fit2)$F[1]==anova(fit)$F[1]
anova(fit2)$F[1]
anova(fit)$F[1]
options(digit=16)
anova(fit2)$F[1]
anova(fit)$F[1]
options(digits = =16)
options(digits  =16)
anova(fit2)$F[1]
anova(fit)$F[1]
anova(fit2)
anova(fit)
load('~/Downloads/group.RData')
View(group)
library(BayesTime)
library(ggplot2)
load("sim_N100_M80.RData")
load('simulated_data_N100_M80_wide.rData')
plot_qqplot(df, 'response')
######### compare to truth ########
N = length(unique(df$id))
J = 2
nknots = params[[1]][[J]]
Q = nknots + 4
K = params[[2]][[J]]
sigma_eps = sqrt(params[[5]][[J]]) # SIGMA_OMEGA_true is error variance
Q1 = params[[1]][[1]] + 4
K1 = params[[2]][[1]]
Theta = params[[6]][(1+Q1):(Q+Q1), (1+K1):(K+K1)] # THETA_true
theta_mu = params[[7]][(1+Q1):(Q+Q1)] # MU_true
ALPHA = t(ALPHA[[1]][(1+K1):(K+K1), ]) # ALPHA
Group = ifelse(ALPHA[, 1] > -0.1, 'G1', 'G2') # 49 in G1 and 51 in G2
# basis
phi_t = phi_t[[J]]
phi_t_stacked=NULL
for(i in 1:N){
phi_t_stacked = rbind(phi_t_stacked, t(phi_t[[i]]))
}
## simulated data
time = Y = MU = F = Omega = Alpha = list()
ids=rep(1:N,each=1)
for (i in 1:N){
time[[i]] = TIME_SPARSE[[1]][[i]][[J]]
Y[[i]] = Y_SPARSE[[1]][[i]][[J]]
MU[[i]] = MU_SPARSE[[1]][[i]][[J]]
F[[i]] = F_SPARSE[[1]][[i]][[J]]
Omega[[i]] = OMEGA_SPARSE[[1]][[i]][[J]]
}
#change not to standardize_kathy_0927
prepared_data <- prepare_data(data = df, unique_subject_id = 'id', time_name = 'time',
response_name = 'response', scale_time = T) # standardized
load('../../../results_pkg/bayesTime_sim_N100_M80_nostandardized.RData')
optimal_model_idx <- optimal(model_list = sfpca_stan_results)
optimal_model <- sfpca_stan_results[[optimal_model_idx]]
#--------------------------------------------
# check model results
#--------------------------------------------
model_output <- output_results(sfpca_data = prepared_data, model = optimal_model)
results_basis = basis_setup_sparse(sfpca_data=prepared_data, nknots=nknots, orth=TRUE)
ALPHA_array = model_output$rotation$alpha_new
MU_array = model_output$rotation$theta_mu_new
THETA_array = model_output$rotation$Theta_new
phi_t_cont = results_basis$orth_spline_basis_cont
time_cont = results_basis$time_cont
N = prepared_data$num_subjects
MU_true = params[[7]][(1+Q1):(Q+Q1)]
FPC_true = params[[8]][, (1+K1):(K+K1)]
time = Y = list()
ids=rep(1:N,each=1)
for (i in 1:N){
time[[i]] = TIME_SPARSE[[1]][[i]][[J]]
Y[[i]] = Y_SPARSE[[1]][[i]][[J]]
}
time_sparse = time # coming from wide format: sampling time point for each subject
Y_sparse = Y # coming from wide format: response for each subject
time_unique = unique(df$time)
time_unique = time_unique[order(time_unique)]
nloop=dim(ALPHA_array)[3]
first=1
last=nloop
MU_mean=MU_array[, 1]
for(iter in 2:nloop){
MU_mean = MU_mean + MU_array[, iter]
}
MU_mean=cbind(MU_mean/(last-first+1))
library(Matrix)
phi_transform = Matrix::bdiag(cbind(phi_t_cont))
Mu_true_functions=t(phi_transform)%*%MU_true
Mu_functions=model_output$Mu_functions
Mu1_true=Mu_true_functions[1:length(time_cont)] # referring to 1st block
Mu1=Mu_functions[1:length(time_cont)]
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10), xlim=c(0,1),lwd=2,col=4,
xlab='time', ylab='Response', font.lab=2, cex.lab=1.2)
dev.off()
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10), xlim=c(0,1),lwd=2,col=4,
xlab='time', ylab='Response', font.lab=2, cex.lab=1.2)
for(i in 1:N){
lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)
}
lines(time_cont,Mu1,type="l",col=2,lwd=2)
legend('topright', c('True', 'Estimated'), col=c(4, 2), lty=c(1,1), bty='n')
THETA_mean = THETA_array[,,first]
for(iter in 2:nloop){
THETA_mean = THETA_mean + THETA_array[,,iter]
}
THETA_mean=cbind(THETA_mean/(last-first+1))
FPC1_mean=model_output$FPC_mean
plot(time_unique,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)),
xlab='time', ylab='PC curve', font.lab=2, cex.lab=1.2)
lines(time_unique,FPC_true[,2],type="l",lwd=1)
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)
optimal_model <- sfpca_stan_results[[4]]
#--------------------------------------------
# check model results
#--------------------------------------------
model_output <- output_results(sfpca_data = prepared_data, model = optimal_model)
results_basis = basis_setup_sparse(sfpca_data=prepared_data, nknots=nknots, orth=TRUE)
ALPHA_array = model_output$rotation$alpha_new
MU_array = model_output$rotation$theta_mu_new
THETA_array = model_output$rotation$Theta_new
phi_t_cont = results_basis$orth_spline_basis_cont
time_cont = results_basis$time_cont
N = prepared_data$num_subjects
MU_true = params[[7]][(1+Q1):(Q+Q1)]
FPC_true = params[[8]][, (1+K1):(K+K1)]
time = Y = list()
ids=rep(1:N,each=1)
for (i in 1:N){
time[[i]] = TIME_SPARSE[[1]][[i]][[J]]
Y[[i]] = Y_SPARSE[[1]][[i]][[J]]
}
time_sparse = time # coming from wide format: sampling time point for each subject
Y_sparse = Y # coming from wide format: response for each subject
time_unique = unique(df$time)
time_unique = time_unique[order(time_unique)]
nloop=dim(ALPHA_array)[3]
first=1
last=nloop
MU_mean=MU_array[, 1]
for(iter in 2:nloop){
MU_mean = MU_mean + MU_array[, iter]
}
MU_mean=cbind(MU_mean/(last-first+1))
library(Matrix)
phi_transform = Matrix::bdiag(cbind(phi_t_cont))
Mu_true_functions=t(phi_transform)%*%MU_true
Mu_functions=model_output$Mu_functions
Mu1_true=Mu_true_functions[1:length(time_cont)] # referring to 1st block
Mu1=Mu_functions[1:length(time_cont)]
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10), xlim=c(0,1),lwd=2,col=4,
xlab='time', ylab='Response', font.lab=2, cex.lab=1.2)
for(i in 1:N){
lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)
}
lines(time_cont,Mu1,type="l",col=2,lwd=2)
#------------------------------------
# BayesTime analysis
#------------------------------------
library(BayesTime)
library(ggplot2) # can this be included in BayesTime
ANTIB <- read.csv('data/DIABIMMUNE_antibiotics.txt', sep='\t')
setwd("~/Dropbox/lab/SFPCA/BayesTime")
ANTIB <- read.csv('data/DIABIMMUNE_antibiotics.txt', sep='\t')
# no duplicated values for age_at_collection; while 80 for month/age_at_collection_binned/age_at_collection_binned_month
sum(duplicated(ANTIB[, c('host_subject_id', 'age_at_collection')])) # 0
plot_qqplot(ANTIB, 'shannon')
dat <- prepare_data(data = ANTIB, unique_subject_id = 'host_subject_id', time_name = 'age_at_collection',
response_name = 'shannon', transform_y = 'standardize', scale_time = T)
sfpca_stan_results <- stan_fit(sfpca_data = dat, Nsamples = 1000, Nchain = 3,
Ncores=3, PC_range = c(1,3,4), nknot_range = c(1,2))
load('../results_pkg/bayesTime_modelSelection_ANTIB_day.RData')
# choose optimal model
optimal_model_idx <- optimal(model_list = sfpca_stan_results)
optimal_model <- sfpca_stan_results[[optimal_model_idx]]
model_output <- output_results(sfpca_data = dat, model = optimal_model)
dat <- prepare_data(data = ANTIB, unique_subject_id = 'host_subject_id', time_name = 'age_at_collection',
response_name = 'shannon', transform_y = 'standardize', scale_time = T)
model_output <- output_results(sfpca_data = dat, model = optimal_model)
library(gridExtra)
#jpeg("../figures/gut_mean_trend.jpeg", width = 5, height = 4, units = 'in', res = 300)
p1 <- plot_mean_curve(output = model_output, original=T,
ymin=NULL, ymax=NULL, x_lab='Age (days)', y_lab='Shannon diversity')$figure
#dev.off()
p1 <- p1 + labs(tag='A')
#jpeg("../figures/gut_fpcs_trend.jpeg", width = 5, height = 4, units = 'in', res = 300)
p2 <- plot_fpc_curve(output = model_output, original=T, pc_idx=c(1,2,3,4),
x_lab='Age (days)', y_lab='Shannon diversity', ymin=2, ymax=6)$figure
#dev.off()
p2 <- p2 + labs(tag='B')
grid.arrange(p1,p2, ncol = 1)
grid.arrange(p1,p2, ncol = 2)
setwd("~/Dropbox/umich/biostat650")
knitr::opts_chunk$set(echo = TRUE)
library(haven)
data <- read_sas('completedata.sas7bdat')
attach(data)
fit <- lm(Depression ~ Fatalism)
summary(fit)
newdf <- data.frame(Depression, Sex)
View(newdf)
mean(newdf[, sex=1]$Depression)
mean(newdf[, newdf$Sex=1]$Depression)
mean(newdf[, newdf$Sex==1]$Depression)
newdf[, newdf$Sex==1]
newdf$Sex
newdf$Sex==1
newdf[, newdf$Sex==1]
mean(newdf[newdf$Sex==1, ]$Depression)
mean(newdf[newdf$Sex==0, ]$Depression)
#sample mean of female
fm <- mean(newdf[newdf$Sex==1, ]$Depression)
#sample mean of male
mm <- mean(newdf[newdf$Sex==0, ]$Depression)
newdf <- data.frame(Depression, Sex)
#sample mean of female
fm <- mean(newdf[newdf$Sex==1, ]$Depression)
#sample mean of male
mm <- mean(newdf[newdf$Sex==0, ]$Depression)
fm - mm
#sample mean of female
fd <- newdf[newdf$Sex==1, ]$Depression
fm <- mean(fd)
fm
#sample mean of male
md <- newdf[newdf$Sex==1, ]$Depression
mm <- mean(mf)
mm <- mean(md)
mm
fm - mm
#sample mean of male
md <- newdf[newdf$Sex==1, ]$Depression
#sample mean of male
md <- newdf[newdf$Sex==0, ]$Depression
mm <- mean(md)
mm
fm - mm
t.test(md, fd, var.equal = T)
t.test(fd, md, var.equal = F)
fit2 <- lm(Depression ~ Sex)
summary(fit2)
fit2$coefficients[1]
fit2$coefficients[2]
fit2$coefficients[2] == (fm-mm)
fit2$coefficients[2]
fm - mm
setwd("~/Dropbox/lab/SFPCA/BayesTime")
#------------------------------------
# BayesTime analysis
#------------------------------------
library(BayesTime)
library(ggplot2) # can this be included in BayesTime
ANTIB <- read.csv('data/DIABIMMUNE_antibiotics.txt', sep='\t')
# no duplicated values for age_at_collection; while 80 for month/age_at_collection_binned/age_at_collection_binned_month
sum(duplicated(ANTIB[, c('host_subject_id', 'age_at_collection')])) # 0
plot_qqplot(ANTIB, 'shannon')
dat <- prepare_data(data = ANTIB, unique_subject_id = 'host_subject_id', time_name = 'age_at_collection',
response_name = 'shannon', transform_y = 'standardize', scale_time = T)
load('../results_pkg/bayesTime_modelSelection_ANTIB_day.RData')
# choose optimal model
optimal_model_idx <- optimal(model_list = sfpca_stan_results)
optimal_model <- sfpca_stan_results[[optimal_model_idx]]
diag <- plot_k_diagnostic(dat, optimal_model)
poster <- plot_posterior_diagnostic(dat, optimal_model)
k_diag <- plot_k_diagnostic(dat, optimal_model)
# 4pc 1 knot: look good
k_diag <- k_diag+labs(tag='a')
k_diag <- plot_k_diagnostic(dat, optimal_model)$figure
library(devtools)
load_all('.')
k_diag <- plot_k_diagnostic(dat, optimal_model)$figure
poster <- plot_posterior_diagnostic(dat, optimal_model)
# 4pc 1 knot: look good
k_diag <- k_diag+labs(tag='a')
poster <- poster+labs(tag='b')
poster <- plot_posterior_diagnostic(dat, optimal_model)
poster <- plot_posterior_diagnostic(dat, optimal_model)$figure
# 4pc 1 knot: look good
k_diag <- k_diag+labs(tag='a')
poster <- poster+labs(tag='b')
grid.arrange(k_diag, poster, ncol = 2)
plot_fpc_boxplot(output = model_output, pc_idx=1, group_name = "csection")$figure # p = 0.055  (before p=0.3)
model_output <- output_results(sfpca_data = dat, model = optimal_model)
#jpeg("../figures/gut_mean_trend.jpeg", width = 5, height = 4, units = 'in', res = 300)
mc <- plot_mean_curve(output = model_output, original=T,
ymin=NULL, ymax=NULL, x_lab='Age (days)', y_lab='Shannon diversity')$figure
#dev.off()
mc <- mc + labs(tag='a')
#jpeg("../figures/gut_fpcs_trend.jpeg", width = 5, height = 4, units = 'in', res = 300)
fpc <- plot_fpc_curve(output = model_output, original=T, pc_idx=c(1,2,3,4),
x_lab='Age (days)', y_lab='Shannon diversity', ymin=2, ymax=6)$figure
#dev.off()
fpc <- fpc + labs(tag='b')
fpc1 <- plot_fpc_on_mean_curve(output = model_output, pc_idx=1,
original = T, sd=T, ymin=2, ymax=5)$figure
fpc2 <- plot_fpc_on_mean_curve(output = model_output, pc_idx=2, original = T, sd=T, ymin=2, ymax=5)$figure
#jpeg("../figures/gut_mean_trend.jpeg", width = 5, height = 4, units = 'in', res = 300)
mc <- plot_mean_curve(output = model_output, original=T,
ymin=NULL, ymax=NULL, x_lab='Age (days)', y_lab='Shannon diversity')$figure
#jpeg("../figures/gut_fpcs_trend.jpeg", width = 5, height = 4, units = 'in', res = 300)
fpc <- plot_fpc_curve(output = model_output, original=T, pc_idx=c(1,2,3,4),
x_lab='Age (days)', y_lab='Shannon diversity', ymin=2, ymax=6)$figure
+ labs(tag='b')
#jpeg("../figures/gut_fpcs_trend.jpeg", width = 5, height = 4, units = 'in', res = 300)
fpc <- (plot_fpc_curve(output = model_output, original=T, pc_idx=c(1,2,3,4),
x_lab='Age (days)', y_lab='Shannon diversity', ymin=2, ymax=6)$figure)
#jpeg("../figures/gut_fpcs_trend.jpeg", width = 5, height = 4, units = 'in', res = 300)
fpc <- (plot_fpc_curve(output = model_output, original=T, pc_idx=c(1,2,3,4),
x_lab='Age (days)', y_lab='Shannon diversity', ymin=2, ymax=6)$figure)+ labs(tag='b')
#jpeg("../figures/gut_mean_trend.jpeg", width = 5, height = 4, units = 'in', res = 300)
mc <- plot_mean_curve(output = model_output, original=T,
ymin=NULL, ymax=NULL, x_lab='Age (days)', y_lab='Shannon diversity')$figure+ labs(tag='a')
#jpeg("../figures/gut_mean_trend.jpeg", width = 5, height = 4, units = 'in', res = 300)
mc <- plot_mean_curve(output = model_output, original=T,
ymin=NULL, ymax=NULL, x_lab='Age (days)', y_lab='Shannon diversity')$figure+ labs(tag='a')
#jpeg("../figures/gut_fpcs_trend.jpeg", width = 5, height = 4, units = 'in', res = 300)
fpc <- (plot_fpc_curve(output = model_output, original=T, pc_idx=c(1,2,3,4),
x_lab='Age (days)', y_lab='Shannon diversity', ymin=2, ymax=6)$figure)+ labs(tag='b')
fpc1 <- plot_fpc_on_mean_curve(output = model_output, pc_idx=1,
original = T, sd=T, ymin=2, ymax=5)$figure + labs(tag='c')
fpc1 <- plot_fpc_on_mean_curve(output = model_output, pc_idx=1,
original = T, sd=T, ymin=2, ymax=5)$figure + labs(tag='c')
fpc2 <- plot_fpc_on_mean_curve(output = model_output, pc_idx=2, original = T, sd=T, ymin=2, ymax=5)$figure
fpc2 <- plot_fpc_on_mean_curve(output = model_output, pc_idx=2, original = T, sd=T, ymin=2, ymax=5)$figure+ labs(tag='d')
grind(mc,fpc, fpc1,fpc2, ncol=2)
grid.arrange(mc,fpc, fpc1,fpc2, ncol=2)
plot_fpc_boxplot(output = model_output, pc_idx=1, group_name = "csection")$figure # p = 0.055  (before p=0.3)
View(ANTIB)
fpc2 <- plot_fpc_on_mean_curve(output = model_output, pc_idx=2, original = T, sd=T, ymin=2, ymax=5)$figure+ labs(tag='d')+
theme(legend. position = "none")
fpc2 <- plot_fpc_on_mean_curve(output = model_output, pc_idx=2, original = T, sd=T, ymin=2, ymax=5)$figure+ labs(tag='d')+
theme(legend.position = "none")
grid.arrange(mc,fpc, fpc1,fpc2, ncol=2)
############ Bayesian SFPCA ####################
library(BayesTime)
set.seed(31)
df = read.csv("data/data_alphas_concise.txt", sep='\t')
## visualize original data
plot_group(data = df, time_name = 'timepoint',
response_name = 'shannon_avg',
unique_subject_id = 'ID_unique', variable_name = 'sample_site')$figure
## check necessity of transformation
plot_qqplot(df, 'shannon_avg')
############ Bayesian SFPCA ####################
library(BayesTime)
set.seed(31)
df = read.csv("data/data_alphas_concise.txt", sep='\t')
## visualize original data
plot_group(data = df, time_name = 'timepoint',
response_name = 'shannon_avg',
unique_subject_id = 'ID_unique', variable_name = 'sample_site')$figure
## prepare data for SFPCA
dat <- prepare_data(data = df, unique_subject_id = 'ID_unique', time_name = 'timepoint',
response_name = 'shannon_avg', transform_y = 'standardize', scale_time = T)
load('../results_pkg/bayesTime_modelSelection.RData')
# choose optimal model
optimal_model_idx <- optimal(model_list = sfpca_stan_results)
#----------------------------------------
# model diagnostics
#----------------------------------------
#optimal_model_idx = 12 # model 18 has fewest extreme values; 3 extreme values with model 12
optimal_model <- sfpca_stan_results[[optimal_model_idx]]
k_diag <- plot_k_diagnostic(dat, optimal_model)$figure + labs(tag='a')
poster <-plot_posterior_diagnostic(dat, optimal_model)$figure + labs(tag='b')
#ggsave('../figures/skin_diagnostic_posterior.pdf', height=4, width=4, units='in', dpi=300)
# data is not very normal, but model is able to cover well (good for both model 18 and 12)
grid.arrange(k_diag, poster, ncol = 2)
ggsave('results_pkg/skin_diagnostic_posterior.pdf', height=4, width=8, units='in', dpi=300)
k_diag <- plot_k_diagnostic(dat, optimal_model)$figure + labs(tag='a')
