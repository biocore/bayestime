dat = read.csv('~/Dropbox/lab/SFPCA/bayesianSFPCA/application_ECAM/data/metadata_shannon.txt', sep='\t')
ECAM <- dat
usethis::use_data(ECAM, overwrite = T)
pkgbuild::compile_dll()
devtools::load_all('BayesTime')
setwd("~/Dropbox/lab/SFPCA")
devtools::load_all('BayesTime')
data("ECAM")
sfpca_qqplot(ECAM, 'shannon')
View(ECAM)
devtools::load_all("BayesTime")
sfpca_qqplot(ECAM, 'shannon')
devtools::load_all("BayesTime")
sfpca_qqplot(ECAM, 'shannon')
ECAM <- ECAM[!duplicated(ECAM[, c('studyid', 'month_of_life')]), ]
dat <- prepare_data(ECAM, unique_subject_id = 'studyid', time_name = 'month_of_life',
response_name = 'shannon', transform_y='standardize', scale_time=T)
sfpca_stan_results <- sfpca_stan(dat, Nsamples = 1000, Nchain = 3, 3, 3)
sfpca_stan_results <- sfpca_stan(dat, Nsamples = 1000, Nchain = 2, 2, 3)
optimal_model <- sfpca_optimal(sfpca_stan_results)
setwd("~/Dropbox/lab/SFPCA")
devtools::load_all('BayesTime')
data("ECAM")
sfpca_qqplot(ECAM, 'shannon')
ECAM <- ECAM[!duplicated(ECAM[, c('studyid', 'month_of_life')]), ]
dat <- prepare_data(ECAM, unique_subject_id = 'studyid', time_name = 'month_of_life',
response_name = 'shannon', transform_y='standardize', scale_time=T)
sfpca_stan_results <- sfpca_stan(dat, Nsamples = 1000, Nchain = 3, 2, 3)
sfpca_stan_results <- sfpca_stan(dat, Nsamples = 1000, Nchain = 3, 3, 3)
optimal_model <- sfpca_optimal(sfpca_stan_results)
save(sfpca_stan_results, '~/Dropbox/lab/SFPCA/results_pkg/stan.RData')
save(sfpca_stan_results, file='~/Dropbox/lab/SFPCA/results_pkg/stan.RData')
optimal_model <- sfpca_optimal(sfpca_stan_results)
devtools::load_all("BayesTime")
plot_diagnostic(dat, optimal_model)
devtools::load_all("BayesTime")
plot_diagnostic(dat, optimal_model)
devtools::load_all("BayesTime")
plot_diagnostic(dat, optimal_model)
devtools::load_all("BayesTime")
plot_diagnostic(dat, optimal_model)
results_basis <- (dat, optimal_model$knot,  orth=TRUE)
results_basis <- (dat, optimal_model$knot, orth=TRUE)
results_basis <- basis_setup_sparse(dat, optimal_model$knot, orth=TRUE)
model_basis <- basis_setup_sparse(dat, optimal_model$knot, orth=TRUE)
model_rotation <- post_hoc_rotation(dat, optimal_model)
devtools::load_all("BayesTime")
devtools::load_all("BayesTime")
model_rotation <- post_hoc_rotation(dat, optimal_model)
View(dat)
View(dat)
d <- dat$data
View(d)
devtools::load_all("BayesTime")
invars <- invariants(ECAM, 'studyid', 'month_of_life')
devtools::load_all("BayesTime")
invars <- invariants(ECAM, 'studyid', 'month_of_life')
model_output <- output_results(dat, invars, model_basis, model_rotation)
model_output <- output_results(dat, invars, model_basis, model_rotation)
devtools::load_all("BayesTime")
devtools::load_all("BayesTime")
model_output <- output_results(dat, invars, model_basis, model_rotation)
dat=sfpca_data
dat<-sfpca_data
sfpca_data <- dat
variables<-invars
basis=model_basis
rotation=model_rotation
npcs <- rotation$npcs
ALPHA_array <- rotation$alpha_new
MU_array <- rotation$theta_mu_new
THETA_array <- rotation$Theta_new
phi_t_cont <- basis$orth_spline_basis_cont
phi_t <- basis$orth_spline_basis_sparse
time_cont <- basis$time_cont
N <- sfpca_data$num_subjects
nloop <- dim(ALPHA_array)[3]
first <- 1
last <- nloop
MU_mean <- MU_array[, first] #mean function across sampling sessions
ALPHA_mean <- ALPHA_array[, , first] # mean factor scores
THETA_mean <- THETA_array[, , first] # mean factor loading
for (iter in 2:nloop) {
MU_mean <- MU_mean + MU_array[, iter]
ALPHA_mean <- ALPHA_mean + ALPHA_array[, , iter]
THETA_mean <- THETA_mean + THETA_array[, , iter]
}
MU_mean <- cbind(MU_mean / (last - first + 1))
ALPHA_mean <- cbind(ALPHA_mean / (last - first + 1))
THETA_mean <- cbind(THETA_mean / (last - first + 1))
cbind(phi_t_cont)
Mu_functions <- t(Matrix::bdiag(cbind(phi_t_cont))) %*% MU_mean
setwd("~/Dropbox/lab/Kids")
library(vegan)
library(tidyr)
library(parallel)
library(rstan)
library(foreach)
library(Matrix)
options(mc.cores = parallel::detectCores())
source('Qiime2/code/sfpca_revised.R')
#only keep kids in yonug group
meta <- read.delim('Qiime2/data/11405_prep_3914_qiime_20190424-152313.txt', sep="\t", stringsAsFactors = F)
meta_young <- meta[meta$age_group == 'young', ]
shannon <-read.csv('Qiime2/data/60671-alpha_shannon/alpha-diversity.tsv', stringsAsFactors=FALSE, sep='\t')
data <- merge(meta_young, shannon, by.x = 'X.SampleID', by.y = 'X')
data$age <- as.numeric(data$age)
age_ix <- which(colnames(data)=='age')
var_names <- colnames(data)[age_ix:ncol(data)]
data_invar_names <- get_invariants(data, var_names, 'host_subject_id', 'age_group_month')
#preprocess data
prepared_data = prepare_data(data=data, unique_subject_id = 'host_subject_id', time_var='age',
response='shannon', transform.y='standardize', scale.time=TRUE)
Nsamples = 1000
Nchains = 3
model_file = "Qiime2/code/sfpca2.stan"
smod = stan_model(model_file)
PC_max = 2 # number of PCs
D_max = 2 # number of knots
#save(sfpca_stan_results, file='Qiime2/results/sfpca/stan_shannon_2pc2knots.RData')
load('Qiime2/results/sfpca/stan_shannon_2pc2knots.RData')
sfpca_model <- get_optimal_model(sfpca_stan_results)
results_basis = basis_setup_sparse(prepared_data=prepared_data, sfpca_model$k, orth=TRUE)
results_rotation <- post_hoc_rotation(sfpca_model, prepared_data, Nchains, Nsamples)
results_list <- output_results(prepared_data, data_invar_names, results_rotation, results_basis)
Matrix::bdiag(cbind(phi_t_cont))
t(Matrix::bdiag(cbind(phi_t_cont)))
model_output <- output_results(dat, invars, model_basis, model_rotation)
devtools::load_all("~/Dropbox/lab/SFPCA/BayesTime")
setwd("~/Dropbox/lab/SFPCA")
devtools::load_all('BayesTime')
data("ECAM")
sfpca_qqplot(ECAM, 'shannon')
ECAM <- ECAM[!duplicated(ECAM[, c('studyid', 'month_of_life')]), ]
qqplot(ECAM, 'shannon')
sfpca_qqplot(ECAM, 'shannon')
ECAM <- ECAM[!duplicated(ECAM[, c('studyid', 'month_of_life')]), ]
invars <- invariants(ECAM, 'studyid', 'month_of_life')
dat <- prepare_data(ECAM, unique_subject_id = 'studyid', time_name = 'month_of_life',
response_name = 'shannon', transform_y='standardize', scale_time=T)
load('~/Dropbox/lab/SFPCA/results_pkg/stan.RData')
optimal_model <- optimal(sfpca_stan_results)
plot_diagnostic(dat, optimal_model)
model_basis <- basis_setup_sparse(dat, optimal_model$knot, orth=TRUE)
model_rotation <- post_hoc_rotation(dat, optimal_model)
model_output <- output_results(dat, invars, model_basis, model_rotation)
devtools::load_all("BayesTime")
model_output <- output_results(dat, invars, model_basis, model_rotation)
sfpca_data <- dat
basis=model_basis
rotation=model_rotation
variables=invars
npcs <- rotation$npcs
ALPHA_array <- rotation$alpha_new
MU_array <- rotation$theta_mu_new
THETA_array <- rotation$Theta_new
phi_t_cont <- basis$orth_spline_basis_cont
phi_t <- basis$orth_spline_basis_sparse
time_cont <- basis$time_cont
N <- sfpca_data$num_subjects
nloop <- dim(ALPHA_array)[3]
first <- 1
last <- nloop
MU_mean <- MU_array[, first] #mean function across sampling sessions
ALPHA_mean <- ALPHA_array[, , first] # mean factor scores
THETA_mean <- THETA_array[, , first] # mean factor loading
for (iter in 2:nloop) {
MU_mean <- MU_mean + MU_array[, iter]
ALPHA_mean <- ALPHA_mean + ALPHA_array[, , iter]
THETA_mean <- THETA_mean + THETA_array[, , iter]
}
MU_mean <- cbind(MU_mean / (last - first + 1))
ALPHA_mean <- cbind(ALPHA_mean / (last - first + 1))
THETA_mean <- cbind(THETA_mean / (last - first + 1))
Mu_functions_temp <- Matrix::bdiag(cbind(phi_t_cont))
Mu_functions <- t(Mu_functions_temp) %*% MU_mean
FPC_mean <- t(phi_t_cont) %*% THETA_mean
vars_complete <- c('ID', 'time', 'response', variables)
tryCatch({
df <- sfpca_data$data[, vars_complete]
}, error = function(e){
cat("ERROR :", 'Selected variables not in data', "\n")
})
Mu_functions_temp <- Matrix::bdiag(cbind(phi_t_cont))
Mu_functions <- t(Mu_functions_temp) %*% MU_mean
model_output <- output_results(dat, invars, model_basis, model_rotation)
model_output <- output_results(sfpca_data=dat, variables=invars, basis=model_basis, rotation=model_rotation)
model_output <- output_results(sfpca_data=dat, variables=invars, basis=model_basis, rotation=model_rotation)
Q
model_output <- output_results(sfpca_data=dat, variables=invars, basis=model_basis, rotation=model_rotation)
devtools::load_all("BayesTime")
model_output <- output_results(sfpca_data=dat, variables=invars, basis=model_basis, rotation=model_rotation)
devtools::load_all("BayesTime")
model_output <- output_results(sfpca_data=dat, variables=invars, basis=model_basis, rotation=model_rotation)
devtools::load_all("BayesTime")
model_rda <- sfpca_rda(model_output, optimal_model)
output<-model_output
model=optimal_model
df <- output$df
df <- df[complete.cases(df), ]
if (is.null(variables)){
dat <- df[, -c('ID', 'time')]
} else {
dat <- df[, variables]
}
df[, -c('ID', 'time')]
View(df)
colnames(df) %in% c('ID', 'time')
df[, !colnames(df) %in% c('ID', 'time')]
devtools::load_all("BayesTime")
model_rda <- sfpca_rda(model_output, optimal_model)
model_rda
if (is.null(variables)){
dat <- df[, !colnames(df) %in% c('ID', 'time')]
} else {
dat <- df[, variables]
}
pc.names <- numeric(model$pc)
pc.names <- sapply(1:model$pc, function(i){
paste('fpc', i, sep = '')
})
pc <- df[, pc.names]
View(pc)
mod0 <- vegan::rda(pc ~ 1., dat)  # Model with intercept only
mod1 <- vegan::rda(pc ~ ., dat)  # Model with all explanatory variables
set.seed(111)
step.res <- vegan::ordiR2step(mod0, mod1, perm.max = 1000)
#add effect-size
table <- step.res$anova
if (is.null(table)) return(print('no non-redundant variable'))
table.row <- nrow(table)
R2.adj <- c(table$R2.adj[1])
for (i in 1:(table.row - 1)) {
R2.adj <- c(R2.adj, table$R2.adj[i+1]-table$R2.adj[i])
}
table$ES.RDA <- R2.adj
table <- table[-table.row, ]
print(step.res$call)
covariates <- rownames(table)
ggplot2::ggplot(table, aes(x=reorder(covariates, ES.RDA), y=ES.RDA,
fill=covariates)) +
labs(x = 'Non-redundant Covariants', y = 'Effect Size') +
geom_bar(stat='identity') +
theme(axis.text=element_text(size=10),
axis.title=element_text(size=14,face="bold"),
legend.position="none") +
coord_flip()
dev.off()
ggplot2::ggplot(table, aes(x=reorder(covariates, ES.RDA), y=ES.RDA,
fill=covariates)) +
labs(x = 'Non-redundant Covariants', y = 'Effect Size') +
geom_bar(stat='identity') +
theme(axis.text=element_text(size=10),
axis.title=element_text(size=14,face="bold"),
legend.position="none") +
coord_flip()
model_rda <- sfpca_rda(model_output, optimal_model)
model_rda
View(df)
devtools::load_all("BayesTime")
model_rda <- sfpca_rda(model_output, optimal_model, invars)
model_rda
devtools::load_all("BayesTime")
plot_residual(model_output)
setwd("~/Dropbox/lab/CRIC/code")
install.packages("rmarkdown")
devtools::use_vignette("bayestime-vignette")
usethis::use_vignette("bayestime-vignette")
setwd("~/Dropbox/lab/SFPCA")
setwd("~/Dropbox/lab/SFPCA/BayesTime")
devtools::load_all(".")
setwd("~/Dropbox/lab/SFPCA")
devtools::load_all("BayesTime")
devtools::load_all("BayesTime")
data("ECAM")
setwd("~/Dropbox/lab/SFPCA")
devtools::load_all("BayesTime")
setwd("~/Dropbox/lab/SFPCA/BayesTime")
devtools::load_all("BayesTime")
library(BayesTime)
data("ECAM")
head(ECAM)
#devtools::load_all("BayesTime")
library(BayesTime)
devtools::build(
)
setwd("~/Dropbox/lab/SFPCA")
devtools::load_all("BayesTime")
source('~/Dropbox/lab/SFPCA/BayesTime/R/invariants.R')
source('~/Dropbox/lab/SFPCA/BayesTime/R/invariants.R')
setwd("~/Dropbox/lab/SFPCA")
devtools::load_all('BayesTime')
data("ECAM")
plot_qqplot(ECAM, 'shannon')
ECAM <- ECAM[!duplicated(ECAM[, c('studyid', 'month_of_life')]), ]
devtools::load_all("BayesTime")
rm(list = c("invariants"))
devtools::load_all("BayesTime")
devtools::load_all('BayesTime')
data("ECAM")
plot_qqplot(ECAM, 'shannon')
ECAM <- ECAM[!duplicated(ECAM[, c('studyid', 'month_of_life')]), ]
invars <- invariants(ECAM, 'studyid', 'month_of_life')
dat <- prepare_data(ECAM, unique_subject_id = 'studyid', time_name = 'month_of_life',
response_name = 'shannon', transform_y='standardize', scale_time=T)
load('~/Dropbox/lab/SFPCA/results_pkg/stan.RData')
optimal_model <- optimal(sfpca_stan_results)
plot_diagnostic(dat, optimal_model)
devtools::load_all("BayesTime")
devtools::load_all("BayesTime")
devtools::load_all("BayesTime")
devtools::load_all(".")
devtools::load_all(".")
