summary(model_list[[9]])
summary(model_list[[10]])
summary(model_list[[2]])
summary(model_list)
model_list = sfpca_stan_results
View(model_list)
N <- data$num_subjects
data = dat
N <- data$num_subjects
loo_best <- model$looic
pkdf <- data.frame(pk = loo_best$diagnostics$pareto_k, id = 1:N)
model = optimal_model
loo_best <- model$looic
pkdf <- data.frame(pk = loo_best$diagnostics$pareto_k, id = 1:N)
View(pkdf)
bad <- pkdf[pkdf$pk > 0.7, ]
View(bad)
devtools::load_all("BayesTime")
plot_k_diagnostic(data = dat, model = optimal_model)
devtools::load_all("BayesTime")
plot_k_diagnostic(data = dat, model = optimal_model)
plot_posterior_diagnostic(data = dat, model = optimal_model)
model_basis <- basis_setup_sparse(dat, nknots = optimal_model$knot, orth=TRUE)
View(dat)
View(data)
colnames(data$data) %in% c('ID', 'time', 'response')
colnames(data$data)[!colnames(data$data %in% var_require)]
var_require <- c('ID', 'time', 'response')
c(var_require, colnames(data$data)[!colnames(data$data %in% var_require)])
vars_complete <- c(var_require, colnames(data$data)[!colnames(data$data) %in% var_require])
!colnames(data$data) %in% var_require
colnames(data$data)[!colnames(data$data) %in% var_require]
vars_complete <- c(var_require, colnames(data$data)[!colnames(data$data) %in% var_require])
devtools::load_all("BayesTime")
model_output <- output_results(data = dat, model = optimal_model)
View(model_output)
lapply(model_output$df, class)
summary(model_output)
#print out the memory use for different data structure
vec_size = 1024L
numeric_vec = rep(1.0,length=vec_size)
integer_vec = rep(1L,length=vec_size)
logical_vec = rep(TRUE,length=vec_size)
character_vec = rep("a",length=vec_size)
A_list = as.list(numeric_vec)
cat("R memory allocated for a numeric vector of length", vec_size, "is", object.size(numeric_vec),"bytes. \n")
cat("R memory allocated for an integer vector of length", vec_size, "is", object.size(integer_vec),"bytes. \n")
cat("R memory allocated for a logical vector of length", vec_size, "is", object.size(logical_vec),"bytes. \n")
cat("R memory allocated for a character vector of length", vec_size, "is", object.size(character_vec),"bytes. \n")
cat("R memory allocated for a list with", length(A_list), "elements is", object.size(A_list),"bytes. \n")
devtools::load_all('.')
library(BayesTime)
data("ECAM")
head(ECAM)
colnames(ECAM)
unique_subject_id <- 'studyid'
time <- 'month_of_life'
response <- 'shannon'
data("ECAM")
head(ECAM)
colnames(ECAM)
unique_subject_id <- 'studyid'
time <- 'month_of_life'
response <- 'shannon'
plot_qqplot(ECAM, response)
plot_group(data = ECAM, time_name = time, response_name = response,
unique_subject_id = unique_subject_id, variable_name = 'delivery')
ECAM <- ECAM[!duplicated(ECAM[, c('studyid', 'month_of_life')]), ]
dat <- prepare_data(data = ECAM, unique_subject_id = unique_subject_id, time_name = time,
response_name = response, transform_y = 'standardize', scale_time = T)
View(dat)
dat <- prepare_data(data = ECAM, unique_subject_id = unique_subject_id, time_name = time,
response_name = response, transform_y = 'standardize', scale_time = T)
View(dat)
dat
summary(dat)
View(dat)
#sfpca_stan_results <- stan_fit(data = dat, Nsamples = 1000, Nchain = 3,
#                         PC_max = 3, D_max = 3)
#save(sfpca_stan_results, file='~/Dropbox/lab/SFPCA/results_pkg/stan_ECAM.RData')
load('~/Dropbox/lab/SFPCA/results_pkg/stan_ECAM.RData')
optimal_model <- optimal(model_list = sfpca_stan_results)
summary(optimal_model)
dat <- prepare_data(data = ECAM, unique_subject_id = unique_subject_id, time_name = time,
response_name = response, transform_y = 'standardize', scale_time = T)
summary(dat)
plot_k_diagnostic(da_list = dat, model = optimal_model)
devtools::load_all(".")
plot_k_diagnostic(da_list = dat, model = optimal_model)
devtools::load_all(".")
plot_k_diagnostic(da_list = dat, model = optimal_model)
plot_posterior_diagnostic(da_list = dat, model = optimal_model)
da_list=dat
('time_ori' %in% colnames(da_list$data)
)
('response_ori' %in% colnames(da_list$data))
if (('time_ori' %in% colnames(da_list$data)) & ('response_ori' %in% colnames(da_list$data))){
var_require <- c('ID', 'time', 'time_ori', 'response', 'response_ori')
} else {
var_require <- c('ID', 'time', 'response')
}
#' generate sfpca models with different parameters
#'
#' @param da_list: The prepared data from prepare_data() function
#' @param model: The optimal model from optimal() function
#' @param variables: A set of variable names insterested in original data
#' @return A list of results from model
#' @importFrom Matrix bdiag
#' @export
output_results <- function(da_list, model, variables = NULL){
basis <- basis_setup_sparse(da_list, nknots = model$knot, orth=TRUE)
rotation <- post_hoc_rotation(da_list, model = model)
npcs <- rotation$npcs
ALPHA_array <- rotation$alpha_new
MU_array <- rotation$theta_mu_new
THETA_array <- rotation$Theta_new
phi_t_cont <- basis$orth_spline_basis_cont
phi_t <- basis$orth_spline_basis_sparse
time_cont <- basis$time_cont
N <- da_list$num_subjects
nloop <- dim(ALPHA_array)[3]
first <- 1
last <- nloop
MU_mean <- MU_array[, first] #mean function across sampling sessions
ALPHA_mean <- ALPHA_array[, , first] # mean factor scores
THETA_mean <- THETA_array[, , first] # mean factor loading
for (iter in 2:nloop) {
MU_mean <- MU_mean + MU_array[, iter]
ALPHA_mean <- ALPHA_mean + ALPHA_array[, , iter]
THETA_mean <- THETA_mean + THETA_array[, , iter]
}
MU_mean <- cbind(MU_mean / (last - first + 1))
ALPHA_mean <- cbind(ALPHA_mean / (last - first + 1))
THETA_mean <- cbind(THETA_mean / (last - first + 1))
Mu_functions_temp <- Matrix::bdiag(cbind(phi_t_cont))
Mu_functions <- t(as.matrix(Mu_functions_temp)) %*% MU_mean
FPC_mean <- t(phi_t_cont) %*% THETA_mean
if (('time_ori' %in% colnames(da_list$data)) & ('response_ori' %in% colnames(da_list$data))){
var_require <- c('ID', 'time', 'time_ori', 'response', 'response_ori')
} else {
var_require <- c('ID', 'time', 'response')
}
if (is.null(variables)){
vars_complete <- c(var_require, colnames(da_list$data)[!colnames(da_list$data) %in% var_require])
} else {
vars_complete <- c('ID', 'time', 'response', variables)
}
tryCatch({
df <- da_list$data[, vars_complete]
}, error = function(e){
cat("ERROR :", 'Input variables are not in data', "\n")
})
Y_sparse <- list()
time_sparse <- list()
scores <- data.frame(t(ALPHA_mean))
if (npcs == 1) {
### create data frame containing needed information ####
df$fpc1 <- 0 # principle component scores
i <- 0
for (pid in unique(df$ID)) {
i <- i + 1
Y_sparse[[i]] <- df$response[df$ID == pid]
time_sparse[[i]] <- df$time[df$ID == pid]
df$fpc1[df$ID == pid] <- scores[i]
}
df$fpc1 <- as.numeric(df$fpc1) # data type issue
Fits_sparse <- list()
for (i in 1:N) {
Fits_sparse[[i]] <- t(phi_t[[i]]) %*% MU_mean + t(phi_t[[i]]) %*% THETA_mean %*% ALPHA_mean[i]
}
df$Y_sparse <- unlist(Y_sparse)
df$Fits_sparse <- unlist(Fits_sparse)
df$residuals <- df$Y_sparse - df$Fits_sparse
} else {
### create data frame containing needed information ####
for (k in 1:npcs) {
names(scores)[k] <- paste('fpc', k, sep = '')
df[names(scores)[k]] <- 0 # principle component scores  # it depends of PCs (better to choose number of PCs as input)
}
i <- 0
for (pid in unique(df$ID)) {
i <- i + 1
Y_sparse[[i]] <- df$response[df$ID == pid]
time_sparse[[i]] <- df$time[df$ID == pid]
for (k in 1:npcs) {
df[, names(scores)[k]][df$ID == pid] <- scores[i, k]
}
}
Fits_sparse <- list()
for (i in 1:N) {
Fits_sparse[[i]] <- t(phi_t[[i]]) %*% MU_mean + t(phi_t[[i]]) %*%
THETA_mean %*% ALPHA_mean[, i]
}
df$Y_sparse <- unlist(Y_sparse) # check: sum(df$Y_sparse != df$response) == 0
df$Fits_sparse <- unlist(Fits_sparse)
df$residuals <- df$Y_sparse - df$Fits_sparse
}
results <- list(df = df,
basis = basis,
rotation = rotation,
Mu_functions = Mu_functions,
time_sparse = time_sparse,
Y_sparse = Y_sparse,
FPC_mean = FPC_mean)
return(results)
}
devtools::load_all(".")
rm(output_results())
model_output <- output_results(da_list = dat, model = optimal_model)
summary(model_output)
View(model_output)
View(model_output)
View(da_list)
View(model_output)
unique(model_output$df$ID)
length(unique(model_output$df$ID))
data=model_output$df
!c('time_ori', 'response_ori') %in% colnames(data)
View(data)
c('time_ori', 'response_ori') %in% colnames(data)
devtools::load_all(".")
plot_mean_curve(sfpca_data = dat, output = model_output, original = T, ymin=NULL, ymax=NULL)
plot_mean_curve(output = model_output, original = T, ymin=NULL, ymax=NULL)
devtools::load_all(".")
plot_mean_curve(output = model_output, original = T, ymin=NULL, ymax=NULL)
devtools::load_all(".")
plot_mean_curve(output = model_output, original = T, ymin=NULL, ymax=NULL)
output=model_output
original = FALSE
ymin=NULL
ymax=NULL
# data <- sfpca_data$data
# N <- sfpca_data$num_subjects
# data <- data[, c(id_name, time_name, response_name)]
# colnames(data) <- c('ID_unique', 'Time', 'response')
data <- output$df
N <- unique(data$ID)
if (original == T){
if ('time_ori' %in% colnames(data) & 'response_ori' %in% colnames(data)){
response <- data$response_ori
time <- data$time_ori
} else {
response <- data$response
time <- data$time
}
} else {
if (!'time_ori' %in% colnames(data) & !'response_ori' %in% colnames(data)){
print('Time and response are not transformed in prepare_data(), plot with original values.')
} else {
response <- data$response
time <- data$time
}
}
sigma_y <- sd(log(response))
View(da_list)
sigma_y <- sd(log(response))
mu_y <- mean(log(response))
time_cont <- output$basis$time_cont
Y_sparse <- output$Y_sparse
Mu_functions <- output$Mu_functions
time_sparse <- output$time_sparse
if (is.null(ymin) & is.null(ymax)) {
ymin <- floor(min(unlist(Y_sparse) * sigma_y + mu_y,
Mu_functions * sigma_y + mu_y)) - 0.1
ymax <- ceiling(max(unlist(Y_sparse) * sigma_y + mu_y,
Mu_functions * sigma_y + mu_y)) + 0.1
}
plot(time_cont * (max(time) - min(time)) + min(time),
Mu_functions * sigma_y + mu_y, type = "l",ylim = c(ymin, ymax),
xlab = 'time', ylab = 'response',
lwd = 5, col = 4, font.lab = 2, cex.lab = 1.2)
View(ECAM)
devtools::load_all(".")
plot_mean_curve(output = model_output, original = T, ymin=NULL, ymax=NULL)
plot_mean_curve(output = model_output, ymin=NULL, ymax=NULL)
# data <- sfpca_data$data
# N <- sfpca_data$num_subjects
# data <- data[, c(id_name, time_name, response_name)]
# colnames(data) <- c('ID_unique', 'Time', 'response')
data <- output$df
N <- unique(data$ID)
if ('time_ori' %in% colnames(data) & 'response_ori' %in% colnames(data)){
response <- data$response_ori
time <- data$time_ori
} else {
response <- data$response
time <- data$time
}
sigma_y <- sd(log(response))
response
log(response)
sigma_y <- sd(log(response))
mu_y <- mean(log(response))
time_cont <- output$basis$time_cont
Y_sparse <- output$Y_sparse
Mu_functions <- output$Mu_functions
time_sparse <- output$time_sparse
if (is.null(ymin) & is.null(ymax)) {
ymin <- floor(min(unlist(Y_sparse) * sigma_y + mu_y,
Mu_functions * sigma_y + mu_y)) - 0.1
ymax <- ceiling(max(unlist(Y_sparse) * sigma_y + mu_y,
Mu_functions * sigma_y + mu_y)) + 0.1
}
floor(min(unlist(Y_sparse)
j
min(unlist(Y_sparse)
* sigma_y + mu_y,
Mu_functions * sigma_y + mu_y)
floor(min(unlist(Y_sparse) * sigma_y + mu_y,
Mu_functions * sigma_y + mu_y))
if (is.null(ymin) & is.null(ymax)) {
ymin <- floor(min(unlist(Y_sparse) * sigma_y + mu_y,
Mu_functions * sigma_y + mu_y)) - 0.1
ymax <- ceiling(max(unlist(Y_sparse) * sigma_y + mu_y,
Mu_functions * sigma_y + mu_y)) + 0.1
}
ymin=NULL
ymax=NULL
if (is.null(ymin) & is.null(ymax)) {
ymin <- floor(min(unlist(Y_sparse) * sigma_y + mu_y,
Mu_functions * sigma_y + mu_y)) - 0.1
ymax <- ceiling(max(unlist(Y_sparse) * sigma_y + mu_y,
Mu_functions * sigma_y + mu_y)) + 0.1
}
plot(time_cont * (max(time) - min(time)) + min(time),
Mu_functions * sigma_y + mu_y, type = "l",ylim = c(ymin, ymax),
xlab = 'time', ylab = 'response',
lwd = 5, col = 4, font.lab = 2, cex.lab = 1.2)
summary(time_sparse)
(max(time) - min(time))
+ min(time), Y_sparse[[i]] * sigma_y + mu_y,
min(time), Y_sparse[[i]] * sigma_y + mu_y
Y_sparse[[i]] * sigma_y + mu_y
lines(time_sparse[[i]] * (max(time) - min(time))
+ min(time), Y_sparse[[i]] * sigma_y + mu_y,
type="l", lwd = .25)
i=1
lines(time_sparse[[i]] * (max(time) - min(time))
+ min(time), Y_sparse[[i]] * sigma_y + mu_y,
type="l", lwd = .25)
i=2
lines(time_sparse[[i]] * (max(time) - min(time))
+ min(time), Y_sparse[[i]] * sigma_y + mu_y,
type="l", lwd = .25)
for (i in 1:N) {
lines(time_sparse[[i]] * (max(time) - min(time))
+ min(time), Y_sparse[[i]] * sigma_y + mu_y,
type="l", lwd = .25)
}
N
devtools::load_all(".")
plot_mean_curve(output = model_output, ymin=NULL, ymax=NULL)
plot_mean_curve(output = model_output, ymin=NULL, ymax=NULL)
devtools::load_all(".")
plot_fpc_curve(output = model_output)
View(dat)
unique_subject_id <- 'studyid'
time <- 'month_of_life'
response <- 'shannon'
invars <- invariants(ECAM, unique_subject_id, time)
devtools::load_all('.')
devtools::load_all('.')
library(BayesTime)
devtools::load_all(".")
library(devtools)
install_github('y1zhong/bayestime')
devtools::load_all('.')
devtools::load_all('.')
library(BayesTime)
devtools::load_all('.')
devtools::load_all(".")
devtools::load_all('.')
library(BayesTime)
data("ECAM")
head(ECAM)
colnames(ECAM)
unique_subject_id <- 'studyid'
time <- 'month_of_life'
response <- 'shannon'
ECAM <- ECAM[!duplicated(ECAM[, c('studyid', 'month_of_life')]), ]
dat <- prepare_data(data = ECAM, unique_subject_id = unique_subject_id, time_name = time,
response_name = response, transform_y = 'standardize', scale_time = T)
#stan_results <- stan_fit(da.list = dat, Nsamples = 1000, Nchain = 3,
#                         PC_max = 3, D_max = 3)
#save(stan_results, file='~/Dropbox/lab/SFPCA/results_pkg/stan_ECAM.RData')
load('~/Dropbox/lab/SFPCA/results_pkg/stan_ECAM.RData')
stop
devtools::load_all('.')
devtools::load_all('.')
library(BayesTime)
data("ECAM")
colnames(ECAM)
unique_subject_id <- 'studyid'
response <- 'shannon'
ECAM <- ECAM[!duplicated(ECAM[, c('studyid', 'month_of_life')]), ]
dat <- prepare_data(data = ECAM, unique_subject_id = unique_subject_id, time_name = time,
response_name = response, transform_y = 'standardize', scale_time = T)
dat <- prepare_data(data = ECAM, unique_subject_id = unique_subject_id, time_name = time,
response_name = response, transform_y = 'standardize', scale_time = T)
data = ECAM
unique_subject_id = unique_subject_id
time_name = time
time_name = time
time <- 'month_of_life'
response <- 'shannon'
dat <- prepare_data(data = ECAM, unique_subject_id = unique_subject_id, time_name = time,
response_name = response, transform_y = 'standardize', scale_time = T)
#stan_results <- stan_fit(da.list = dat, Nsamples = 1000, Nchain = 3,
#                         PC_max = 3, D_max = 3)
#save(stan_results, file='~/Dropbox/lab/SFPCA/results_pkg/stan_ECAM.RData')
load('~/Dropbox/lab/SFPCA/results_pkg/stan_ECAM.RData')
optimal_model <- optimal(model_list = stan_results)
stan_results <- stan_fit(da.list = dat, Nsamples = 1000, Nchain = 3,
PC_max = 3, D_max = 3)
stan_results <- stan_fit(da_list = dat, Nsamples = 1000, Nchain = 3,
PC_max = 3, D_max = 3)
devtools::load_all(".")
stan_results <- stan_fit(da_list = dat, Nsamples = 1000, Nchain = 3,
PC_max = 3, D_max = 3)
save(stan_results, file='~/Dropbox/lab/SFPCA/results_pkg/stan_ECAM.RData')
optimal_model <- optimal(model_list = stan_results)
summary(optimal_model)
plot_k_diagnostic(da_list = dat, model = optimal_model)
plot_posterior_diagnostic(da_list = dat, model = optimal_model)
model_output <- output_results(da_list = dat, model = optimal_model)
plot_mean_curve(output = model_output, ymin=NULL, ymax=NULL)
plot_fpc_curve(output = model_output)
plot_fpc_boxplot(output = model_output, group_name = invars)
View(ECAM)
plot_fpc_boxplot(output = model_output, group_name = 'delivery')
data = model_output$df
View(data)
View(model_output)
K=3
fpcs <- c()
for (k in 1:K){
fpcs <- c(fpcs, paste('fpc', k, sep = ''))
}
data_temp <- data[, c('unique_subject_id', 'delivery', fpc1')]
}
}
## effect of mean of two groups
for (k in 1:K){
#pdf(paste(paste('shannon_sfpca/FPCs_mean_PC_GroupMean_shannon_fecal', k, sep=''), 'pdf', sep='.'), width=5, height=5)
scores_mu_g1 = mean(df[df$birth_mode_ms %in% 'CS', paste('fpc', k, sep='')])
scores_mu_g2 = mean(df[df$birth_mode_ms %in% 'CSseed', paste('fpc', k, sep='')])
scores_mu_g3 = mean(df[df$birth_mode_ms %in% 'Vag', paste('fpc', k, sep='')])
plot(time_cont*max(dat$Time), Mu_functions*sigma_y + mu_y, type="n",
lwd=2,col=1, xlab='Time', ylab='shannon', font.lab=2, cex.lab=1.2, ylim=c(1.7,3.5))
lines(time_cont*max(dat$Time), (Mu_functions + FPC_mean[,k]*scores_mu_g1)*sigma_y + mu_y,type="l",lwd=3,lty=2,col=2) # red
lines(time_cont*max(dat$Time), (Mu_functions + FPC_mean[,k]*scores_mu_g2)*sigma_y + mu_y,type="l",lwd=3,lty=2,col=3) # green
lines(time_cont*max(dat$Time), (Mu_functions + FPC_mean[,k]*scores_mu_g3)*sigma_y + mu_y,type="l",lwd=3,lty=2,col=4) #
title(main=paste(paste('PC', k, sep=' '), ' (', prop_var_avg[k], ' )', sep=''))
#axis(1, font=2) # make x-axis ticks label bold
legend('bottomright', c('CS', 'CSseed', 'Vaginal'), lty=c(2,2,2), lwd=c(3,3,3), col=c(2,3,4), bty='n', cex=0.5)
#dev.off()
}
data_temp <- data[, c('unique_subject_id', 'delivery', 'fpc1')]
View(data)
data_temp <- data[, c('ID', 'delivery', 'fpc1')]
View(data_temp)
data_wide <- tidyr::spread(data_temp, 'delivery', 'fpc1')
classes <- factors(data_temp$delivery)
classes <- factor(data_temp$delivery)
classes[1]
data_wide <- data_temp[data_temp[, 'delivery'] == classes[1], ]
View(data_wide)
View(data_wide)
output=model_output
group_name='delivery'
plot_fpc_boxplot(output = model_output, group_name = 'delivery')
plot_fpc_boxplot(output = model_output, group_name = 'delivery')
plot_fpc_boxplot(output = model_output, group_name = 'deiet')
plot_fpc_boxplot(output = model_output, group_name = 'diet')
plot_fpc_boxplot(output = model_output, group_name = 'diet_3')
#for (i in 1:length(group_name)) {
df_temp <- data.frame(df$ID, df$fpc1, df[, group_name])
df <- output$df
#for (i in 1:length(group_name)) {
df_temp <- data.frame(df$ID, df$fpc1, df[, group_name])
colnames(df_temp) <- c('ID', 'fpc', 'var_temp')
#df_temp <- df_temp[which(df_temp[, 3] != 'Missing: Not provided'), ]
df_temp[, 3] <-  factor(df_temp[, 3])
pairwise.t.test(df_temp[, 3])
pairwise.t.test(df_temp, de_temp[, 3])
pairwise.t.test(df_temp, df_temp[, 3])
View(df_temp)
pairwise.t.test(df_temp[,3], factor(df_temp[, 3]))
df_temp[,3]
factor(df_temp[, 3])
attach(airquality)
Month <- factor(Month, labels = month.abb[5:9])
Ozone
Month
pairwise.t.test(df_temp[, 2], factor(df_temp[, 3]))
a <- pairwise.t.test(df_temp[, 2], factor(df_temp[, 3]))
View(a)
group_name
group_name='diet'
group_name='diet_3'
#for (i in 1:length(group_name)) {
df_temp <- data.frame(df$ID, df$fpc1, df[, group_name])
colnames(df_temp) <- c('ID', 'fpc', 'var_temp')
#df_temp <- df_temp[which(df_temp[, 3] != 'Missing: Not provided'), ]
df_temp[, 3] <-  factor(df_temp[, 3])
a <- pairwise.t.test(df_temp[, 2], factor(df_temp[, 3]))
View(a)
a[["p.value"]]
usethis::use_package("car")
usethis::use_package("bayesplot")
usethis::use_package("vegan")
usethis::use_package("ggpubr")
